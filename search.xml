<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「代数学方法：第一卷」第 1 章学习笔记</title>
    <url>/2022/01/21/ai-jabr-1-1/</url>
    <content><![CDATA[<p><strong>Zermelo-Fraenkel Set Theory (ZFC)</strong> 构筑于：</p>
<ul>
<li>一阶逻辑：$\land,\neg,\implies,\forall,\exists$ 等逻辑连词和量词，括号 $(\ )$，变元 $x,y,z,\cdots$ 和等号 $=$，以及判定公式是否合法的规则。</li>
<li>集合论所需的二元谓词 $\in$ 及下述的九条公理。ZFC 处理的所有对象均为集合。</li>
</ul>
<span id="more"></span>

<p><strong>外延公理 (<em>Extensionality</em>).</strong> 若两集合有相同元素，则两者相等。</p>
<p><strong>配对公理 (<em>Pair</em>).</strong> 对任意 $x,y$，存在 $\{x,y\}$。</p>
<p><strong>分离公理模式 (<em>Separation</em>).</strong> 设 $P$ 为关于集合的一个性质，以 $P(u)$ 表示集合 $u$ 满足性质 $P$，则对任意集合 $X$ 存在 $\{u\in X:P(u)\}$。</p>
<p><strong>并集公理 (<em>Union</em>).</strong> 对任意集合 $X$，存在相应的并集 $\bigcup X:=\{u:\exists x\in X,u\in x\}$。</p>
<p><strong>幂集公理 (<em>Power Set</em>).</strong> 对任意集合 $X$，其子集构成集合 $\mathcal P(X):=\{u:u\subset X\}$。</p>
<p><strong>无穷公理 (<em>Infinity</em>).</strong> 存在集合 $X$ 使得 $\varnothing\in X$ 且 $x\in X\implies x\cup\{x\}\in X$。</p>
<p><strong>替换公理模式 (<em>Replacement</em>).</strong> 设 $F$ 为以一个集合 $X$ 为定义域的函数，则存在集合 $F(X):=\{F(x):x\in X\}$。</p>
<p><strong>正则公理 (<em>Foundation</em>).</strong> 对任意非空集 $X$，存在 $x\in X$ 使得对所有 $y\in X$ 都有 $y\notin x$。</p>
<p><strong>选择公理 (<em>Choice</em>).</strong> 对任意集合 $X$，若 $\forall x\in X$ 都有 $x\ne\varnothing$，则存在函数 $g:X\to\bigcup X$ 使得 $\forall x\in X$ 都有 $g(x)\in X$。</p>
<p>由此定义集合的并、交、差、积和子集等运算，以及元组、函数、$n$ 元关系等概念。</p>
<p><strong>偏序集</strong>是指集合及其二元关系 $(P,\le)$ 满足：</p>
<ul>
<li>反身性：$\forall x\in P,x\le x$；</li>
<li>传递性：$(x\le y)\land(y\le z)\implies x\le z$；</li>
<li>反对称性：$(x\le y)\land(y\le x)\implies x=y$。</li>
</ul>
<p>仅满足反身性和传递性则称为<strong>预序集</strong>。预序集间满足 $x\le y\implies f(x)\le f(y)$ 的映射称为<strong>保序映射</strong>。</p>
<p>设 $P,Q$ 为偏序集，若映射 $\varphi:P\to Q$ 满足 $x&lt;x’\implies\varphi(x)&lt;\varphi(x’)$ 则称 $\varphi$ 是<strong>严格增</strong>的。</p>
<p>若 $\varphi:P\to Q$ 是双射且 $\varphi,\varphi^{-1}$ 都严格增，则称 $\varphi$ 为偏序集 $P,Q$ 间的<strong>同构</strong>。偏序集的同构类称为<strong>序型</strong>。</p>
<p>设 $P’\subset P$ 而 $P$ 为预序集，对于 $x\in P$，</p>
<ul>
<li>若不存在 $y\in P$ 使得 $x&lt;y$，则称 $x$ 是 $P$ 的<strong>极大元</strong>；</li>
<li>若 $\forall x’\in P’$ 都有 $x’\le x$，则称 $x$ 是 $P’$ 的<strong>上界</strong>；</li>
<li>若 $x$ 是 $P’$ 的上界且对每个上界 $y$ 都有 $x\le y$，则称 $x$ 是 $P’$ 的<strong>上确界</strong>。</li>
</ul>
<p>同理可以定义<strong>极小元</strong>、<strong>下界</strong>和<strong>下确界</strong>。若 $P$ 是偏序集则上/下确界存在则唯一，记为 $\sup P’$ 和 $\inf P’$。</p>
<p>若偏序集 $P$ 非空且任意 ${x,y}$ 都有上界，则称 $P$ 是<strong>滤过</strong>的。</p>
<p>若偏序集 $P$ 满足 $x\le y\lor y\le x$，则称为<strong>全序集</strong>。</p>
<p>若全序集 $P$ 满足每个非空子集都有极小元则称为<strong>良序集</strong>。</p>
<p><strong>例 1.</strong> 对任意集合 $X$，则幂集 $\mathcal P(X)$ 对包含关系 $\subset$ 构成滤过偏序集。</p>
<p><strong>引理 1.</strong> 设 $P$ 为良序集，映射 $\varphi:P\to P$ 严格增，则 $\forall x\in P$ 都有 $\varphi(x)\ge x$。</p>
<p><strong>证明.</strong> 反证法，不妨设 $P_0=\{x\in P:\varphi(x)&lt;x\}$ 非空，极小元为 $z$，则 $\varphi(z)\in P_0$ 而 $\varphi(z)&lt;z$，矛盾。$\square$</p>
<p><strong>推论 1.</strong> $P$ 没有非平凡的自同构。</p>
<p><strong>推论 2.</strong> 对任意 $x\in P$，不存在从 $P$ 到 $P_{&lt;x}$ 的同构。</p>
<p>若集合 $\alpha$ 的每个元素都是它的子集，则称 $\alpha$ 是<strong>传递</strong>的。</p>
<p>若传递集 $\alpha$ 对 $\in$ 构成良序集，则称 $\alpha$ 为<strong>序数</strong>。</p>
<p><strong>引理 2-1.</strong> 若 $\alpha$ 是序数，$\beta\in\alpha$，则 $\beta$ 是序数。</p>
<p><strong>证明.</strong> 由 $\alpha$ 的传递性知 $\beta\subset\alpha$，则 $(\beta,\in)$ 是良序集。</p>
<p>若 $\tau\in\beta\subset\alpha$，因为 $(\alpha,\in)$ 是序结构所以 $x\in\tau\in\beta\implies x\in\beta$，也即 $\tau\subset\beta$，所以 $\beta$ 是序数。$\square$</p>
<p><strong>引理 2-2.</strong> 对任意两个序数 $\alpha,\beta$，若 $\alpha\subsetneq\beta$，则 $\alpha\in\beta$。</p>
<p><strong>证明.</strong> 设 $\gamma$ 为 $(\beta\backslash\alpha,\in)$ 的极小元，则 $\gamma=\{x\in\beta:x\in\gamma\}$，显然 $\gamma\subset\alpha$。</p>
<p>对所有 $y\in\alpha\subset\beta$，显然 $\gamma\ne y$，若 $\gamma\in y$，又因为 $y\subset\alpha$ 所以 $\gamma\in\alpha$，矛盾；所以 $y\in\gamma$，即 $\alpha\subset\gamma$，所以 $\alpha=\gamma\in\beta$。$\square$</p>
<p><strong>引理 2-3.</strong> 对任意两个序数 $\alpha,\beta$，必有 $\alpha\subset\beta$ 或 $\beta\subset\alpha$。</p>
<p><strong>证明.</strong> 设 $\gamma=\alpha\cap\beta$，则 $\gamma$ 也是序数，由引理 2-2 得证。$\square$</p>
<p><strong>定理 3.</strong> 定义 $\mathbf{On}$ 为全体序数构成的真类，则：</p>
<ul>
<li>$(\mathbf{On},\in)$ 构成全序，且对任意序数 $\alpha$ 都有 $\alpha=\{\beta:\beta&lt;\alpha\}$；</li>
<li>设 $C$ 是由序数构成的非空类，则 $\inf C:=\bigcap C$ 也是序数，且 $\inf C\in C$，且 $\alpha\sqcup{\alpha}=\inf\{\beta:\alpha&lt;\beta\}$。</li>
<li>设 $S$ 是由序数构成的集合，则 $\sup S:=\bigcup S$ 也是序数。</li>
</ul>
<p>给定序数 $\alpha$，定义 $\alpha+1:=\alpha\sqcup\{\alpha\}$，称为 $\alpha$ 的<strong>后继</strong>。若 $\alpha$ 不是任何序数的后继，则称为<strong>极限序数</strong>。</p>
<p>定义无穷序数 $\omega=\mathbb Z_{\ge 0}$，则 $\omega$ 也是极限序数。</p>
<p><strong>定理 4 (超穷归纳法).</strong> 设 $C$ 是由序数构成的类，若</p>
<ul>
<li>$0\in C$；</li>
<li>$\alpha\in C\implies\alpha+1\in C$；</li>
<li>设 $\alpha$ 为极限序数，若对每个 $\beta&lt;\alpha$ 皆有 $\beta\in C$，则 $\alpha\in C$。</li>
</ul>
<p>则 $C=\mathbf{On}$。若仅考虑小于 $\theta$ 的序数则仍然成立。</p>
<p><strong>定理 5 (超穷递归原理).</strong> 设 $\mathbf{V}$ 表示所有集合构成的类，$G:\mathbf V\to\mathbf V$，则：</p>
<ul>
<li>对任意序数 $\theta$，称函数 $a:\theta\to V$ 为 $\theta$-列，则存在唯一的 $\theta$-列 $a$ 使得 $a&lt;\theta\implies a(\alpha)=G(a|_\alpha)$，其中 $a|_\alpha$ 表示函数限制 $\{(\beta,a(\beta)):\beta&lt;\alpha\}$。</li>
<li>存在唯一的函数 $a:\mathbf{On}\to V$ 使得对每个序数 $\alpha$ 都有 $a(\alpha)=G(a|_\alpha)$。</li>
</ul>
<p>利用超穷递归原理可以对序数定义加法、乘法和指数。</p>
<p><strong>定理 6.</strong> 对任意良序集 $P$，存在唯一的序数 $\alpha$ 和良序集之间的同构 $\varphi:P\xrightarrow{\sim}\alpha$。</p>
<p><strong>证明.</strong> 不妨设 $P\ne\varnothing$，并选取 $\mho\notin P$，设 $a_0:=\min(P)$，利用超穷递归定义<br>$$<br>a_\alpha:=\begin{cases}\min(P\backslash{a_\beta:\beta&lt;\alpha}),&amp;\{a_\beta:\beta&lt;\alpha\}\subsetneq P, \ \mho,&amp;\{a_\beta:\beta&lt;\alpha\}=P.\end{cases}<br>$$<br>因为 $P$ 是集合，所以存在最小的序数 $\theta$ 使得 $a_\theta=\mho$，此时 $a_\alpha\mapsto\alpha$ 定义了偏序集的同构 $P\to\theta$。$\square$</p>
<p><strong>定理 7 (良序公理).</strong> 任意集合 $S$ 都能被赋予良序。</p>
<p><strong>证明.</strong> 选取 $\mho\notin S$ 如上。根据选择公理，对 $S$ 的每个子集 $S’$ 选择其元素 $g(S’)$。设 $a_0=g(S)$，利用超穷递归定义<br>$$<br>a_\alpha:=\begin{cases}g(S\backslash{a_\beta:\beta&lt;\alpha}),&amp; S\ne\{a_\beta:\beta&lt;\alpha\}, \<br>\mho,&amp;S=\{a_\beta:\beta&lt;\alpha\}.\end{cases}<br>$$<br>同理可得存在最小的序数 $\theta$ 使得 $a_\theta=\mho$，此时 $a_\alpha\mapsto\alpha$ 定义了 $S$ 与 $\theta$ 的同构，于是导出 $S$ 上的良序。$\square$</p>
<p><strong>定理 8 (Zorn 引理).</strong> 设 $P$ 为非空偏序集，并且 $P$ 中每个链都有上界，则 $P$ 含有极大元。</p>
<p><strong>证明.</strong> 反证法，假设没有极大元，根据选择公理，对 $P$ 的每个链 $P’$ 选择比它的上界大的元素 $g(P’)$。任取 $a_0\in P$，利用超穷递归定义 $a_\alpha:=g(\{a_\beta:\beta&lt;\alpha\})$，得出 $\mathbf{On}$ 到 $P$ 的单射，矛盾。$\square$</p>
<hr>
<p>若两集合 $X,Y$ 之间存在双射 $\varphi:X\to Y$，则称 $X,Y$ <strong>等势</strong>。集合 $X$ 的等势类记作 $|X|$，若存在单射 $\varphi:X\to Y$ 则记作 $|X|\le|Y|$。</p>
<p><strong>定理 9 (Schröder–Bernstein).</strong> 若两集合 $X,Y$ 满足 $|X|\le |Y|$ 且 $|Y|\le |X|$，则 $|X|=|Y|$。</p>
<p><strong>证明.</strong> 考虑单射 $f:X\to Y$ 和 $g:Y\to X$，则以 $g(Y)$ 代替 $Y$ 即得 $f(X)\subset Y\subset X$，定义 $X_0:=X$，$Y_0:=Y$，$X_{n+1}:=f(X_n)$，$Y_{n+1}:=f(Y_n)$。定义映射 $\varphi:X\to Y$ 如下<br>$$<br>\varphi(x)=\begin{cases}f(x),&amp;\exists n\in\mathbb N,x\in X_n\backslash Y_n, \ x,&amp;\text{otherwise.}\end{cases}<br>$$<br>则 $\varphi$ 是 $X$ 和 $Y$ 之间的双射。$\square$</p>
<p><strong>定理 10 (Cantor).</strong> 对任意集合 $X$ 都有 $|\mathcal P(X)|&gt;X$。</p>
<p><strong>证明.</strong> 对于映射 $\varphi:X\to\mathcal P(X)$，必有 ${x:x\notin\varphi(x)}\notin\varphi(X)$。$\square$</p>
<p>若序数 $\kappa$ 满足对任意序数 $\lambda&lt;\kappa$ 都有 $|\lambda|&lt;|\kappa|$，则称 $\kappa$ 为<strong>基数</strong>。</p>
<p><strong>定理 11.</strong> 对任意集合 $X$ 可取最小的序数 $\alpha(X)$ 使得 $|X|=|\alpha(X)|$，则 $X\mapsto\alpha(X)$ 给出等势类与基数的双射。</p>
<p><strong>证明.</strong> 良序公理说明了 $\alpha(X)$ 的存在性，由序数的良序性得证。$\square$</p>
<p>基数为有限序数的集合称为<strong>有限集</strong>，基数为 $\omega$ 的集合称为<strong>可数集</strong>，其余称为<strong>不可数集</strong>。</p>
<p><strong>引理 12-1.</strong> 对任意序数 $\alpha$ 存在基数 $\kappa&gt;\alpha$。</p>
<p><strong>证明.</strong> 反证法，若对所有序数 $\theta$ 都有 $|\theta|\le|\alpha|$，则有 $\mathbf{On}\to\alpha$，矛盾。$\square$</p>
<p><strong>引理 12-2.</strong> 设 $S$ 是基数构成的集合，则 $\sup S$ 是基数。</p>
<p><strong>证明.</strong> 反证法，若存在序数 $\beta&lt;\alpha:=\sup S$ 满足 $|\beta|=|\alpha|$，由上确界性质知存在 $\kappa\in S$ 使得 $|\beta|\le|\kappa|\le|\alpha|$，则 $|\beta|=|\kappa|$，矛盾。$\square$</p>
<p>任意无穷集 $\alpha$ 都满足 $|\alpha\sqcup{\alpha}|=|\alpha|$，所以无穷基数必为极限序数。</p>
<p>由上述引理可以用序数枚举无穷基数：$\aleph_0:=\omega$，$\aleph_{\alpha+1}:=$ 大于 $\aleph_\alpha$ 的最小基数，若 $\alpha$ 为极限序数则 $\aleph_\alpha:=\sup{\aleph_\beta:\beta&lt;\alpha}$。</p>
<p><strong>例 2.</strong> 因为 Dedekind 分割 $x\mapsto{r\in\mathbb Q:r&lt;x}$ 给出 $\mathbb R\hookrightarrow\mathcal P(\mathbb Q)$，所以 $|\mathbb R|\le|\mathcal P(\mathbb Q)|=2^{\aleph_0}$，而区间 $[0,1]$ 包含<br>$$<br>C=\left\{\sum_{n\ge 0}a_n3^{-n}:\forall n,a_n=0\ 或\ 2\right\},<br>$$<br>所以 $|\mathbb R|\ge |C|=2^{\aleph_0}$，所以 $|\mathbb R|=2^{\aleph_0}$。</p>
<p>在真类 $\mathbf{On}^2$ 上定义 $(\alpha,\beta)\prec(\alpha’,\beta’)$ 当且仅当</p>
<ul>
<li>$\max(\alpha,\beta)&lt;\max(\alpha’,\beta’)$，或者</li>
<li>$\max(\alpha,\beta)=\max(\alpha’,\beta’)$ 且 $(\alpha,\beta)$ 的字典序比 $(\alpha’,\beta’)$ 小。</li>
</ul>
<p>则对任意序数 $\alpha$ 都有 $\mathbf{On}^2_{\prec(0,\alpha)}=(\alpha\times\alpha,\prec)$，称作 <strong>$\alpha\times\alpha$ 上的典范良序</strong>。</p>
<p><strong>定理 13.</strong> 对任意序数 $\alpha$ 都有 $(\aleph_\alpha\times\aleph_\alpha,\prec)$ 的序型为 $\aleph_\alpha$。</p>
<p><strong>证明.</strong> 反证法，设 $\alpha$ 为不满足命题的最小序数，显然 $\alpha&gt;0$，设 $(\aleph_\alpha\times\aleph_\alpha,\prec)$ 的序型为 $\gamma$，取同构 $f:\gamma\to(\aleph_\alpha\times\aleph_\alpha,\prec)$，则由基数性质知 $\gamma\ge|\gamma|=|\aleph_\alpha\times\aleph_\alpha|\ge\aleph_\alpha$，又因为 $\gamma\ne\aleph_\alpha$，所以 $\gamma&gt;\aleph_\alpha$，因为 $\aleph_\alpha$ 是 $\gamma$ 的真前段，所以限制 $f$ 得到 $\aleph_\alpha$ 到 $(\aleph_\alpha\times\aleph_\alpha,\prec)$ 的某个真前段的同构，而 $\mathbf{On}^2_{\prec(0,\aleph_\alpha)}$ 的真前段必定包含于 $\sigma\times\sigma$，其中 $\sigma&lt;\aleph_\alpha$，由基数性质知存在 $\beta&lt;\alpha$ 使得 $|\sigma|=\aleph_\beta$，所以由 $\alpha$ 的最小性得 $\aleph_\alpha=|f(\aleph_\alpha)|\le|\sigma|^2=\aleph_\beta$，矛盾。$\square$</p>
<p><strong>推论 14.</strong> 对于至少一个无穷的非零基数 $\kappa,\lambda$，$\kappa+\lambda=\kappa\cdot\lambda=\max(\kappa,\lambda)$，且若 $2\le\kappa\le\lambda$ 则 $\kappa^\lambda=2^\lambda$。</p>
<p>对于基数 $\alpha$，若不存在极限序数 $\beta&lt;\alpha$ 和严格增的序数列 $\{a_\xi:\xi&lt;\beta\}$ 使得 $\sup\{a_\xi:\xi&lt;\beta\}=\alpha$，则称 $\alpha$ 为<strong>正则基数</strong>。</p>
<p><strong>例 3.</strong> 对于任意序数 $\gamma$，$\aleph_{\gamma+\omega}$ 都不是正则基数：取 $\beta=\gamma+\omega$，$a_\xi=\aleph_\xi$ 即可。</p>
<hr>
<p>若集合 $\mathcal U$ 满足以下条件则称为<strong>宇宙</strong>：</p>
<ul>
<li>$\mathcal U$ 是传递集：$u\in\mathcal U\implies u\subset\mathcal U$；</li>
<li>$u,v\in\mathcal U\implies\{u,v\}\in\mathcal U$；</li>
<li>$u\in\mathcal U\implies\mathcal P(u)\in\mathcal U$；</li>
<li>若 $I\subset\mathcal U$，则一族集合 ${u_i:i\in I}\subset\mathcal U$ 的并 $\bigcup_{i\in I}u_i\in\mathcal U$；</li>
<li>$\varnothing\in\mathcal U$。</li>
</ul>
<p>对于集合 $X$，若 $X\in\mathcal U$ 则称为 <strong>$\mathcal U$-集</strong>；若 $X$ 和一个 $\mathcal U$-集等势则称为 <strong>$\mathcal U$-小集</strong>。</p>
<p>定义一族由序数枚举的集合 $V_\alpha$ 如下：$V_0:=\varnothing$；$V_{\alpha+1}:=\mathcal P(V_\alpha)$；$\alpha$ 是极限序数时 $V_\alpha:=\bigcup_{\beta&lt;\alpha}V_\beta$。称为集合的<strong>层叠谱系</strong>。</p>
<p><strong>定理 15-1.</strong> 任何非空的类 $C$ 都有相对于 $\in$ 的极小元 $x$。</p>
<p><strong>证明.</strong> 任取 $S\in C$，若 $S\cap C=\varnothing$ 则 $S$ 即为所求，否则令 $S_0:=S$，$S_{n+1}:=\bigcup S_n$，$T:=\bigcup_{n\in\mathbb N}S_n$ 可得传递集 $T\supset S$，令 $X:=T\cap C$，由正则公理知 $X$ 中有相对于 $\in$ 的极小元 $x$。下证 $x$ 是 $(C,\in)$ 的极小元：否则存在 $y\in x\cap C$，因为 $T$ 是传递集且 $x\in T$，所以 $y\in T\cap C=X$，矛盾。$\square$</p>
<p><strong>定理 15-2.</strong> 任意集合都属于某个 $V_\alpha$，其中 $\alpha$ 是序数。</p>
<p><strong>证明.</strong> 反证法，取 $C$ 为所有不在任一个 $V_\alpha$ 内的集合构成的类，$x$ 为 $C$ 相对于 $\in$ 的极小元，所以 $\forall z\in x,z\in V_{\alpha(z)}$，由替换公理模式知 $\mathcal O:=\{\alpha(z):z\in x\}$ 是序数构成的集合，取 $\theta:=\sup\mathcal O$，则 $x\subset V_\mathcal\theta$，也即 $x\in V_{\theta+1}$，矛盾。$\square$</p>
<p>对于基数 $\kappa$，若 $\kappa$ 不可数，是正则基数，且对任意基数 $\lambda&lt;\kappa$ 都有 $2^\lambda&lt;\kappa$，则称 $\kappa$ 为<strong>强不可达基数</strong>。</p>
<p><strong>推论 3.</strong> 宇宙即为层叠谱系中形如 $V_\kappa$ 的成员，其中 $\kappa$ 是一个强不可达基数。</p>
<p><strong>Grothendieck 假设.</strong> 对任意基数 $\lambda$，存在强不可达基数 $\kappa$ 使得 $\lambda&lt;\kappa$。或者说，每个集合都属于宇宙。</p>
<p><em>Note.</em> ZFC 公理系统无法证明强不可达基数的存在性。</p>
<p><strong>习题 6 (König 定理).</strong> 设 $\kappa_i,\lambda_i$ 为两族以 $i\in I$ 为下标的基数，且对每个 $i\in I$ 都有 $\kappa_i&lt;\lambda_i$，证明：$\sum_{i\in I}\kappa_i&lt;\sum_{i\in I}\lambda_i$。</p>
<p>$\le$ 是显然的。反证法，取集合 $|E_i|=\lambda_i$，$E:=\prod_{i\in I}E_i$，则存在划分 $E=\bigcup_{i\in I}F_i$，$|F_i|=\kappa_i$。</p>
<p>对每个 $i\in I$，令 $G_i:=\text{Im}[F_i\hookrightarrow E\to E_i]$，其中映射取恒等映射和正则投射，则 $G_i\subsetneq E_i$，取 $f\in\prod_{i\in I}(E_i\backslash G_i)$，则 $f\notin\bigcup F_i$，矛盾。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>抽象代数</tag>
      </tags>
  </entry>
  <entry>
    <title>XVIII Open Cup, GP of Khamovniki</title>
    <url>/2021/10/06/XVIII-Open-Cup-GP-of-Khamovniki/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/102155">题目链接</a></p>
<span id="more"></span>

<h1 id="I-le-or-ge"><a href="#I-le-or-ge" class="headerlink" title="I. $\le$ or $\ge$"></a>I. $\le$ or $\ge$</h1><p><strong>这是一道交互题</strong></p>
<p>交互器有 $n$ 个栈，每个栈有 $k$ 个元素，都是不大于 $10^9$ 的正整数，初始时你只知道栈顶的元素，每次操作你选取正整数 $x$，交互器选择 $\le x$ 或 $\ge x$，将满足条件的栈顶元素弹出，然后交互器告诉你新的栈顶元素。你需要在 $50$ 次操作之内将所有栈弹空。</p>
<p>$n=10^4$，$k=10$。交互器是自适应的。</p>
<hr>
<p>考虑暴力即为每次选中位数，但会被卡到 $k\lfloor\log_2 n\rfloor$ 次操作。</p>
<p>我们不想让每次都弹小的栈，所以给大小为 $k$ 的栈赋 $\alpha^k$ 的权值，每次将权值对半分，最坏的操作次数是 $(k\log\alpha+\log n)/\log(2\alpha/(\alpha+1))$，三分一下得到当 $\alpha=3.909$ 时取到最小值 $49.09$，懒一点就取 $\alpha=4$，而且卡不满，测试数据 $43$ 次就可以搞完。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10003</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, a[N], id[N], siz[N], pw[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++ i)&#123;siz[i] = k; id[i] = i;&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10</span>;++ i) pw[i] = <span class="number">1</span>&lt;&lt;i*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		LL sum = <span class="number">0</span>, res = <span class="number">0</span>; <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++ i) sum += pw[siz[i]];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++ i) cin &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">sort</span>(id, id + n, [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;<span class="keyword">return</span> a[x] &lt; a[y] || a[x] == a[y] &amp;&amp; x &lt; y;&#125;);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++ i)</span><br><span class="line">			<span class="keyword">if</span>((res += pw[siz[id[i]]]) * <span class="number">2</span> &gt;= sum)&#123;</span><br><span class="line">				cout &lt;&lt; (p = a[id[i]]) &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span>(*op == <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(*op == <span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++ i)</span><br><span class="line">				<span class="keyword">if</span>(siz[i] &amp;&amp; a[i] &lt;= p) -- siz[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++ i)</span><br><span class="line">				<span class="keyword">if</span>(siz[i] &amp;&amp; a[i] &gt;= p) -- siz[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="G-Piecewise-Linearity"><a href="#G-Piecewise-Linearity" class="headerlink" title="G. Piecewise Linearity"></a>G. Piecewise Linearity</h1><p>给定一个分段 $1$ 次函数，问能否表示为 $\sum\lambda_i|x-a_i|$ 的形式。</p>
<p>$n\le 10^5$。</p>
<hr>
<p>如果只看每段的斜率的话只需第一段和最后一段的斜率相反，所以还需要一个关于纵坐标的方程，然后再推推推就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> n, x[N], y[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;++ i)</span><br><span class="line">		cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">	<span class="built_in">puts</span>(((LL)y[n]-y[n<span class="number">-1</span>])*(x[<span class="number">1</span>]-x[<span class="number">0</span>]) + ((LL)y[<span class="number">1</span>]-y[<span class="number">0</span>])*(x[n]-x[n<span class="number">-1</span>]) || ((LL)y[<span class="number">0</span>]+y[n])*(x[<span class="number">1</span>]-x[<span class="number">0</span>])+((LL)y[<span class="number">1</span>]-y[<span class="number">0</span>])*(x[n]-x[<span class="number">0</span>]) ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="F-Shuffle"><a href="#F-Shuffle" class="headerlink" title="F. Shuffle"></a>F. Shuffle</h1><p>对于 $s=s_0s_1\cdots s_{n-1}\pod{2\mid n}$，定义 $\text{shuffle}(s)=s_0s_2\cdots s_{n-2}s_1s_3\cdots s_{n-1}$。</p>
<p>给定两个字符串 $s,t$，求最小的自然数 $k$ 使得 $\text{shuffle}^{(k)}(s)=t$。需判断无解。</p>
<p>$2\le |s|=|t|\le 10^6$，$|s|$ 是偶数，$\Sigma=\{\texttt{a,b,}\cdots\texttt{,z}\}$。</p>
<hr>
<p>这个变换就是一个置换，每个环的限制是线性同余方程（因为若多种移位都满足则环上字符是循环串），可以用 exKMP 或哈希做匹配，然后直接 exCRT 解方程组即可。</p>
<p>这个置换可以看成 $x\mapsto 2x\pmod{n-1}$，所以每个模数都是 $\varphi(n-1)$ 的因数，即答案如果存在就不会很大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000003</span>, K = <span class="number">100003</span>, B = <span class="number">257</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], t[N], s1[N], t1[N];</span><br><span class="line"><span class="keyword">int</span> n, m, nxt[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">LL a[K], p[K];</span><br><span class="line">ULL hs2[N&lt;&lt;<span class="number">1</span>], pw[N];</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a, LL b, LL mod)</span></span>&#123;</span><br><span class="line">	a %= mod; b %= mod;</span><br><span class="line">	LL tmp = a*b - (LL)((LD)a/mod*b+<span class="number">0.5</span>)*mod;</span><br><span class="line">	<span class="keyword">return</span> tmp &lt; <span class="number">0</span> ? tmp+mod : tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)&#123;x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">	LL g = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x; <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s+<span class="number">1</span>, t+<span class="number">1</span>); n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(s[<span class="number">1</span>] != t[<span class="number">1</span>] || s[n] != t[n])&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i += <span class="number">2</span>) nxt[i] = i+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i += <span class="number">2</span>) nxt[i] = i+n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++ i) pw[i] = pw[i<span class="number">-1</span>] * B;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>;_ &lt;= n;++ _) <span class="keyword">if</span>(!vis[_])&#123;</span><br><span class="line">		<span class="keyword">int</span> u = _, len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;vis[u] = <span class="number">1</span>; s1[++len] = s[u]; t1[len] = t[u]; u = nxt[u];&#125; <span class="keyword">while</span>(u != _);</span><br><span class="line">		ULL hs1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;++ i)&#123;</span><br><span class="line">			hs1 = hs1 * B + s1[i];</span><br><span class="line">			hs2[i] = hs2[i<span class="number">-1</span>] * B + t1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = len+<span class="number">1</span>;i &lt;= (len&lt;&lt;<span class="number">1</span>);++ i)</span><br><span class="line">			hs2[i] = hs2[i<span class="number">-1</span>] * B + t1[i-len];</span><br><span class="line">		a[++m] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++ i)</span><br><span class="line">			<span class="keyword">if</span>(hs2[i+len] - hs2[i]*pw[len] == hs1)&#123;</span><br><span class="line">				a[m] = i; <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(a[m] == <span class="number">-1</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;++ i)</span><br><span class="line">			<span class="keyword">if</span>(hs2[i+len] - hs2[i]*pw[len] == hs2[len])&#123;</span><br><span class="line">				p[m] = i; <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(p[m] == <span class="number">1</span>) -- m;</span><br><span class="line">	&#125;</span><br><span class="line">	LL x, y, M = p[<span class="number">1</span>], ans = a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= m;++ i)&#123;</span><br><span class="line">		LL c = (a[i] - ans % p[i] + p[i]) % p[i];</span><br><span class="line">		LL g = <span class="built_in">exgcd</span>(M, p[i], x, y), bg = p[i] / g;</span><br><span class="line">		<span class="keyword">if</span>(c % g)&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">		x = <span class="built_in">mul</span>(x, c / g, bg);</span><br><span class="line">		ans += x * M; M *= bg;</span><br><span class="line">		ans = (ans % M + M) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="E-Oneness"><a href="#E-Oneness" class="headerlink" title="E. Oneness"></a>E. Oneness</h1><p>对于正整数 $n$，设 $f(n)$ 表示 $n$ 的因数中在十进制表示下只有数字 $1$ 且不是 $1$ 的个数。</p>
<p>随机生成 $l$ 位正整数 $n$，求 $\sum_{k=1}^n f(k)$。</p>
<p>$l\le 2.5\cdot 10^5$。</p>
<hr>
<p>考虑令 $n:=9n$，所求即为 $\lfloor n/99\rfloor+\lfloor n/999\rfloor+\cdots=n(1/99+1/999+\cdots)-\{n/99\}-\{n/999\}-\cdots$。</p>
<p>第一项可以先算出那个常数的十进制表示然后 FFT 做高精度乘法，剩下的小数部分直接算，因为随机生成数据所以精度问题不是很大。</p>
<p>时间复杂度 $O(l\log l)$，代码咕掉了 /dk</p>
<p><em>To be continued…</em></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OpenCup</tag>
      </tags>
  </entry>
  <entry>
    <title>「代数学方法：第一卷」第 2 章学习笔记</title>
    <url>/2022/01/21/ai-jabr-1-2/</url>
    <content><![CDATA[<p>一个<strong>范畴</strong> $\mathcal C$ 包含：</p>
<ul>
<li>集合 $\text{Ob}(\mathcal C)$，其元素称为 $\mathcal C$ 的<strong>对象</strong>；</li>
<li>集合 $\text{Mor}(\mathcal C)$，其元素称为 $\mathcal C$ 的<strong>态射</strong>；</li>
<li>一对映射 $s,t:\text{Mor}(\mathcal C)\to\text{Ob}(\mathcal C)$，分别给出态射的<strong>来源</strong>和<strong>目标</strong>。</li>
<li>对于 $X,Y\in\text{Ob}(\mathcal C)$，定义 $\text{Hom}_\mathcal C(X,Y):=s^{-1}(X)\cap t^{-1}(Y)$ 为 <strong>$\text{Hom}$-集</strong>，其元素称为 <strong>$X$ 到 $Y$ 的态射</strong>。</li>
<li>对于 $X\in\text{Ob}(\mathcal C)$，定义 $\text{id}_X\in\text{Hom}_\mathcal C(X,X)$，称为 $X$ 到自身的<strong>恒等态射</strong>。</li>
<li>对于 $X,Y,Z\in\text{Ob}(\mathcal C)$，给定态射间的<strong>合成映射</strong> $\circ:\text{Hom}_\mathcal C(X,Y)\times\text{Hom}_\mathcal C(Y,Z)\to\text{Hom}_\mathcal C(X,Z),(f,g)\mapsto f\circ g$。它满足：<ul>
<li>结合律：对于 $f,g,h\in\text{Mor}(\mathcal C)$，若 $(fg)h$ 和 $f(gh)$ 都有定义，则 $(fg)h=f(gh)$；</li>
<li>对于 $f\in\text{Hom}_\mathcal C(X,Y)$ 有 $f\circ \text{id}_X=f=\text{id}_Y\circ f$。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>称 $\mathcal C’$ 是 $\mathcal C$ 的<strong>子范畴</strong>是指：</p>
<ul>
<li>$\text{Ob}(\mathcal C’)\subset\text{Ob}(\mathcal C)$；</li>
<li>对任意 $X,Y\in\text{Ob}(\mathcal C’)$ 有 $\text{Hom}_{\mathcal C’}(X,Y)\subset\text{Hom}_\mathcal C(X,Y)$ 且与态射的合成兼容。</li>
</ul>
<p>若 $\text{Hom}_{\mathcal{C’}}(X,Y)=\text{Hom}_\mathcal C(X,Y)$ 则称 $\mathcal C’$ 是<strong>全子范畴</strong>。<del>导出子图（bushi</del></p>
<p>一个范畴 $\mathcal C$ 称为 <strong>$\mathcal U$-范畴</strong>是指对任意对象 $X,Y$，$\text{Hom}_\mathcal C(X,Y)$ 都是 $\mathcal U$-小集。若 $\text{Mor}(\mathcal C)$ 也是 $\mathcal U$-小集则称为 <strong>$\mathcal U$-小范畴</strong>。</p>
<p><em>之后定义的结构（群、环、拓扑空间等）作为集合都是事先选定的宇宙 $\mathcal U$ 的集合，范畴也都是 $\mathcal U$-范畴。</em></p>
<p>设 $X,Y\in\text{Ob}(\mathcal C)$，$f:X\to Y$ 为态射，</p>
<ul>
<li>若对任意 $Z\in\text{Ob}(\mathcal C)$ 和 $g,h:Z\to X$ 都有 $fg=fh\iff g=h$，则称 $f$ 为<strong>单态射</strong>；</li>
<li>若对任意 $Z\in\text{Ob}(\mathcal C)$ 和 $g,h:Y\to Z$ 都有 $gf=hf\iff g=h$，则称 $f$ 为<strong>满态射</strong>；</li>
<li>若存在 $g:Y\to X$ 使得 $gf=\text{id}_X$，则称 $f$ <strong>左可逆</strong>而 $g$ 是 $f$ 的一个<strong>左逆</strong>，此时 $f$ 必为单态射；</li>
<li>若存在 $g:Y\to X$ 使得 $fg=\text{id}_Y$，则称 $f$ <strong>右可逆</strong>而 $g$ 是 $f$ 的一个<strong>右逆</strong>，此时 $f$ 必为满态射；</li>
<li>若 $f$ 既左可逆又右可逆则称 $f$ 是<strong>同构</strong>。</li>
</ul>
<p>$X$ 到 $Y$ 的同构集记作 $\text{Isom}_\mathcal C(X,Y)$。$X$ 的自同态集记作 $\text{End}_\mathcal C(X):=\text{Hom}_\mathcal C(X,X)$，自同构集记作 $\text{Aut}_\mathcal C(X):=\text{Isom}_\mathcal C(X,X)$。</p>
<p>关于合成运算 $\circ$，$\text{End}_\mathcal C(X)$ 是含幺半群，$\text{Aut}_\mathcal C(X)$ 是群。</p>
<p>若范畴 $\mathcal C$ 的所有态射都可逆，则称为<strong>广群</strong>。</p>
<p><strong>例 1 (基本广群).</strong> 设 $X$ 是拓扑空间，其基本广群 $\Pi_1(X)$ 定义为如下范畴：对象是 $X$ 中的点，态射为两点间道路的同伦类。$\pi_1(X,x):=\text{Aut}(x)$ 称为以 $x$ 为基点的<strong>基本群</strong>。</p>
<p>范畴 $\mathcal C$ 的<strong>反范畴</strong> $\mathcal C^{\text{op}}$ 定义为反转箭头和复合运算。</p>
<p>设 $\mathcal C’$ 和 $\mathcal C$ 是范畴，<strong>函子</strong> $F:\mathcal C’\to\mathcal C$ 包含：</p>
<ul>
<li>对象间的映射 $F:\text{Ob}(\mathcal C’)\to\text{Ob}(\mathcal C)$；</li>
<li>态射间的映射 $F:\text{Mor}(\mathcal C’)\to\text{Mor}(\mathcal C)$，使得<ul>
<li>$F$ 与来源映射和目标映射相交换；</li>
<li>保复合运算和恒等态射。</li>
</ul>
</li>
</ul>
<p>对于函子 $F:\mathcal C’\to\mathcal C$，</p>
<ul>
<li>若 $\mathcal C$ 中任意对象都同构于某个 $FX$ 则称 $F$ 是<strong>本质满</strong>的。</li>
<li>若对 $X,Y\in\text{Ob}(\mathcal C’)$ 都有 $\text{Hom}_\mathcal C(X,Y)\to\text{Hom}_\mathcal C(FX,FY)$ 是单射，则称 $F$ 是<strong>忠实</strong>的；</li>
<li>若对 $X,Y\in\text{Ob}(\mathcal C’)$ 都有 $\text{Hom}_\mathcal C(X,Y)\to\text{Hom}_\mathcal C(FX,FY)$ 是满射，则称 $F$ 是<strong>全</strong>的。</li>
</ul>
<p>函子 $F,G:\mathcal C’\to\mathcal C$ 的<strong>自然变换</strong> $\theta$ 是一族态射 $\theta_X\in\text{Hom}_\mathcal C(FX,GX)\ (X\in\text{Ob}(\mathcal C’))$ 使得对所有 $\mathcal C’$ 中的态射 $f:X\to Y$ 都有：</p>
<p><img src="/images/ai-jabr-2-1.png"></p>
<p>记作 $\theta:F\to G$。<em>一种理解方法是 $\theta$ 为 $F$ 到 $G$ 的一个同伦。</em></p>
<p>对于 $\mathcal C’$ 到 $\mathcal C$ 的三个函子间的态射 $\theta:F\to G$ 和 $\psi:G\to H$，<strong>纵合成</strong> $\psi\circ\theta:=\{\psi_X\circ\theta_X:X\in\text{Ob}(\mathcal C’)\}.$</p>
<p>对于三个范畴 $\mathcal C’’$、$\mathcal C’$ 和 $\mathcal C$ 的函子 $F_1,F_2:\mathcal C’’\to\mathcal C’$ 和 $G_1,G_2:\mathcal C’\to\mathcal C$ 间的态射 $\theta:F_1\to F_2$ 和 $\psi:G_1\to G_2$，<strong>横合成</strong> $\psi\circ\theta:G_1\circ F_1\to G_2\circ F_2.$</p>
<p><strong>引理 1-1.</strong> 上述纵、横合成都是函子间的态射，且都满足结合律。</p>
<p><strong>证明.</strong> 纵合成是显然的。现证明横合成的自然性，只需证明右图。</p>
<p><img src="/images/ai-jabr-2-2.png"></p>
<p>而由 $\psi$ 和 $\theta$ 的自然性知每块均交换，而水平方向的合成分别为 $(\psi\circ\theta)_X$ 和 $(\psi\circ\theta)_Y$，此即说明 $\psi\circ\theta$ 的自然性。</p>
<p>现证明横合成的结合律，考虑左图，施 $\psi$ 的自然性于 $F_1(X)\to F_2(X)$ 知其交换，所以对于三对函子间映射 $\theta:F_1\to F_2$，$\psi:G_1\to G_2$，$\varphi:H_1\to H_2$ 下图给出 $(\varphi\circ(\psi\circ\theta))_X$ 和 $((\varphi\circ\psi)\circ\theta)_X$，而施 $\varphi$ 的自然性于 $G_2F_1(X)\to G_2F_2(X)$ 知其交换。$\square$</p>
<p><img src="/images/ai-jabr-2-3.png"></p>
<p>对于自然变换 $\theta:F_1\to F_2$，若每个 $\theta_X$ 都是同构，则存在 $\psi:F_2\to F_1$ 使得 $\psi\circ\theta=\text{id}_{F_1}$ 且 $\theta\circ\psi=\text{id}_{F_2}$，称 $\psi$ 是 $\theta$ 的逆，记作 $\theta^{-1}$，并称 $\theta$ 是 $F_1$ 到 $F_2$ 的<strong>自然同构</strong>。显然同构的横纵合成均为同构。</p>
<p>对于一对函子 $F:\mathcal C_1\to\mathcal C_2$ 和 $G:\mathcal C_2\to\mathcal C_1$，若存在自然同构 $\theta:\text{id}_{\mathcal C_2}\to FG$ 和 $\psi:\text{id}_{\mathcal C_1}\to GF$ 则称 $G$ 是 $F$ 的<strong>拟逆函子</strong>，并称 $F$ 是范畴 $\mathcal C_1$ 到 $\mathcal C_2$ 的<strong>等价</strong>。若进一步有 $FG=\text{id}_{\mathcal C_2}$ 且 $GF=\text{id}_{\mathcal C_1}$ 则称 $G$ 是 $F$ 的<strong>逆</strong>，并称 $F$ 是范畴间的<strong>同构</strong>。</p>
<p><strong>命题 2.</strong> 设 $G,G’$ 是函子 $F:\mathcal C_1\to\mathcal C_2$ 的拟逆，则存在函子间同构 $G\cong G’$。</p>
<p><strong>证明.</strong> 自然变换的横合成给出 $G\xrightarrow{\psi’\circ\text{id}_G}(G’F)G=G’(FG)\xleftarrow{\text{id}_{G’}\circ\theta}G’$。$\square$</p>
<p>对于全子范畴 $\mathcal C’\subset\mathcal C$，若对每个 $X\in\text{Ob}(\mathcal C)$ 都存在唯一的 $Y\in\text{Ob}(\mathcal C’)$ 使得存在 $X$ 到 $Y$ 的同构，则称 $\mathcal C’$ 是 $\mathcal C$ 的一副<strong>骨架</strong>。自为骨架的范畴称为<strong>骨架范畴</strong>。</p>
<p><strong>引理 3-1.</strong> 任意范畴 $\mathcal C$ 均有一副骨架 $\mathcal C’$，且包含函子 $\iota:\mathcal C’\to\mathcal C$ 是等价。</p>
<p><strong>证明.</strong> 使用选择公理在 $\text{Ob}(\mathcal C)$ 的每个同构类中取代表元，设其构成的全子范畴为 $\mathcal C’$。</p>
<p>对每个 $X\in\text{Ob}(\mathcal C)$ 选定同构 $\theta_X:X\to \kappa(X)$，其中 $\kappa(X)\in\text{Ob}(\mathcal C’)$，特别地对于 $X\in\text{Ob}(\mathcal C’)$ 有 $\theta_X=\text{id}_X$。</p>
<p>此时存在唯一一种方法将 $\kappa:\text{Ob}(\mathcal C)\to\text{Ob}(\mathcal C’)$ 延拓为函子并使得 $\theta:\text{id}_\mathcal C\to\iota\kappa$ 是自然同构：对于 $f\in\text{Hom}_\mathcal C(X,Y)$ 定义 $\kappa(f):=\theta_Y\circ f\circ\theta_X^{-1}\in\text{Hom}_{\mathcal C’}(\kappa(X),\kappa(Y))$。同时由定义有 $\kappa\iota=\text{id}_{\mathcal C’}$，所以 $\kappa$ 是 $\iota$ 的拟逆函子。$\square$</p>
<p><strong>引理 3-2.</strong> 骨架范畴间的全忠实、本质满函子都是同构。</p>
<p><strong>定理 4.</strong> 对于函子 $F:\mathcal C_1\to\mathcal C_2$，$F$ 是范畴等价 $\iff$ $F$ 是全忠实、本质满函子。</p>
<p><strong>证明.</strong> $\implies$：设拟逆函子为 $G:\mathcal C_2\to\mathcal C_1$ 以及自然同构 $\psi:GF\to\text{id}_{\mathcal C_1}$ 和 $\varphi:FG\to\text{id}_{\mathcal C_2}$。</p>
<p>对任意 $Z\in\text{Ob}(\mathcal C_2)$ 都有同构 $\varphi_Z:F(GZ)\to Z$ 故 $F$ 本质满，同理 $G$ 本质满。</p>
<p>因为 $f\mapsto Ff\mapsto GF(f)\mapsto\psi_YGF(f)\psi_X^{-1}$ 合成为恒等映射，所以 $F$ 左可逆，同理可知当 $X,Y\in\text{Ob}(\mathcal C_1)$ 属于 $G$ 的像时 $\text{Hom}(X,Y)\xrightarrow F\text{Hom}(FX,FY)$ 右可逆，而 $\mathcal C_1$ 中每个对象都同构于 $G$ 的某个像，所以 $F$ 全忠实。</p>
<p>$\impliedby$：由引理 3-1 取骨架 $\iota_i:\mathcal C_i’\to\mathcal C_i$ 及其拟逆函子 $\kappa_i\ (i=1,2)$，$F’:=\kappa_2\circ F\circ \iota_1:\mathcal C_1’\to\mathcal C_2’$ 也是全忠实、本质满函子，所以 $F’$ 是范畴同构。设 $G:=\iota_1\circ F’^{-1}\circ\kappa_2$，则由自然变换的横合成知：</p>
<p>$$<br>\begin{aligned}<br>GF&amp;=\iota_1F’^{-1}\kappa_2F\cong\iota_1F’^{-1}\kappa_2F\iota_1\kappa_1=\iota_1\kappa_1\cong\text{id}_{\mathcal C_1}, \\<br>FG&amp;=F\iota_1F’^{-1}\kappa_2\cong\iota_2\kappa_2\iota_1F’^{-1}\kappa_2F=\iota_2\kappa_2\cong\text{id}_{\mathcal C_2}.\square<br>\end{aligned}<br>$$</p>
<p><strong>例 2.</strong> 给定域 $\mathbb K$，定义范畴 $\textsf{Mat}$ 如下：对象是 $\mathbb Z_{\ge 0}$，$\text{Hom}(n,m):=M_{m\times n}(\mathbb K)$，态射的合成定义为矩阵乘法。定义函子 $F:\textsf{Mat}\to\text{Vect}_f(\mathbb K)$，$F(n)=\mathbb K^{\oplus n}:=M_{n\times 1}(\mathbb K)$，而对 $A\in\text{Hom}(n,m)$，线性映射 $FA:\mathbb K^{\oplus n}\to\mathbb K^{\oplus m}$ 是矩阵乘法 $v\mapsto Av$，则 $F$ 是范畴等价。</p>
<hr>
<p>设 $I$ 是 $\mathcal U$-集，$\{\mathcal C_i:i\in I\}$ 是一族范畴。积范畴 $\prod_{i\in I}\mathcal C_i$ 定义为：</p>
<p>$$<br>\begin{aligned}<br>\text{Ob}\left(\prod_{i\in I}\mathcal C_i\right)&amp;:=\prod_{i\in I}\text{Ob}(\mathcal C_i), \\<br>\text{Hom}_{\prod_{i\in I}\mathcal C_i}((X_i)_i,(Y_i)_i)&amp;:=\prod_{i\in I}\text{Hom}_{\mathcal C_i}(X_i,Y_i).<br>\end{aligned}<br>$$</p>
<p>其中 $(X_i)_i$ 表示 $\prod_{i\in I}\text{Ob}(\mathcal C_i)$ 的元素。余积（无交并）范畴 $\coprod_{i\in I}\mathcal C_i$ 定义为：</p>
<p>$$<br>\begin{aligned}<br>\text{Ob}\left(\coprod_{i\in I}\mathcal C_i\right)&amp;:=\coprod_{i\in I}\text{Ob}(\mathcal C_i), \\<br>\text{Hom}_{\coprod_{i\in I}\mathcal C}(X_j,X_k)&amp;:=\begin{cases}\text{Hom}_{\mathcal C_j}(X_j,X_k),&amp;j=k, \\ \varnothing,&amp;j\ne k.\end{cases}<br>\end{aligned}<br>$$</p>
<p>其中对每个 $j\in I$，$X_j\in\mathcal C_j$。</p>
<p>定义投射函子 $\mathbf{pr}_j:\prod_{i\in I}\mathcal C_i\to\mathcal C_j$ 和包含函子 $\iota_j:\mathcal C_j\to\coprod_{i\in I}\mathcal C_i$。</p>
<p>形如 $F:\mathcal C_1\times\cdots\times\mathcal C_n\to\mathcal C$ 的函子称为 <strong>$n$ 元函子</strong>。 </p>
<p><strong>例 3 (Hom 函子).</strong> 给定范畴 $\mathcal C$，因为 $\mathcal C$ 中的每一对态射 $f:X’\to X$ 和 $g:Y\to Y’$ 诱导出<br>$$<br>\begin{aligned}<br>\text{Hom}_\mathcal C(X,Y)&amp;\to\text{Hom}_\mathcal C(X’,Y’), \\<br>\varphi&amp;\mapsto g\varphi f.<br>\end{aligned}<br>$$<br>称为态射 $\varphi$ 对 $f$ 作<strong>拉回</strong>，对 $g$ 作<strong>推出</strong>。拉回记为 $f^\star\varphi=\varphi f$，推出记为 $g_\star\varphi=g\varphi$，易知 $(f_1f_2)^\star=f_2^\star f_1^\star$ 且 $(f_1f_2)_\star=(f_1)_\star(f_2)_\star$。</p>
<p>所以 $(X,Y)\mapsto\text{Hom}_\mathcal C(X,Y)$ 定义了二元函子 $\text{Hom}_\mathcal C:\mathcal C^{\text{op}}\times\mathcal C\to\textsf{Set}$。</p>
<p>设 $\mathcal C_1,\mathcal C_2$ 是 $\mathcal U$-范畴，定义<strong>函子范畴</strong>：对象是 $\mathcal C_1$ 到 $\mathcal C_2$ 的函子，$F,G$ 之间的态射是自然变换 $\theta:F\to G$，合成是自然变换的纵合成。记作 $\text{Fct}(\mathcal C_1,\mathcal C_2)$ 或 $\mathcal C_2^{\mathcal C_1}$。</p>
<p>若 $\mathcal C_1$ 是 $\mathcal U$-小范畴，则 $\text{Fct}(\mathcal C_1,\mathcal C_2)$ 的每个态射是<br>$$<br>\prod_{X\in\text{Ob}(\mathcal C_1)}\text{Hom}_{\mathcal C_2}(FX,GX)<br>$$<br>的子集，此时 $\text{Fct}(\mathcal C_1,\mathcal C_2)$ 是 $\mathcal U$-范畴。</p>
<p><strong>命题 5.</strong> 存在自然同构 $\text{Fct}(\mathcal C_1,\mathcal C_2)^{\text{op}}\to\text{Fct}(\mathcal C_1^{\text{op}},\mathcal C_2^{\text{op}})$，它将 $\varphi$ 映至 $\varphi^{\text{op}}$。</p>
<p><strong>证明.</strong> 对函子 $F,G:\mathcal C_1\to\mathcal C_2$，在反范畴中相应地有 $F^{\text{op}},G^{\text{op}}:\mathcal C_1^{\text{op}}\to\mathcal C_2^{\text{op}}$，而自然变换 $\varphi:F\to G$ 在反范畴中被倒转为 $\varphi^{\text{op}}:G^{\text{op}}\to F^{\text{op}}$。$\square$</p>
<p><strong>例 4.</strong> 对于集合 $I\in\mathcal U$，取 $\mathcal I:=\textsf{Disc}(I)$ 为相应的离散范畴，则对每个范畴 $\mathcal C$ 皆有范畴同构 $\mathcal C^{\mathcal I}\cong\prod_{i\in I}\mathcal C$。</p>
<p>定义范畴 $\mathcal C$ 的<strong>中心</strong>为 $Z(\mathcal C)=\text{End}(\text{id}_{\mathcal C})$，其元素即为一族自同态 $\psi_X:X\to X$ 使得对每个 $f:X\to Y$ 都有 $f\circ\psi_X=\psi_Y\circ f$。</p>
<p><strong>命题 6.</strong> 中心 $Z(\mathcal C)$ 对二元运算 $\circ$ 交换。</p>
<p><strong>证明.</strong> 对于 $X\in\text{Ob}(\mathcal C)$，$\varphi,\psi\in Z(\mathcal C)$，在定义中取 $X=Y$，$f=\varphi_X$ 即可。$\square$</p>
<p><strong>命题 7.</strong> 范畴等价 $F:\mathcal C_1\to\mathcal C_2$ 诱导中心的同构 $Z(\mathcal C_1)\cong Z(\mathcal C_2)$。</p>
<p><strong>证明.</strong> 对于同构的对象 $X,Y$，设 $f:X\to Y$ 可逆，则对 $\psi\in Z(\mathcal C)$ 有 $f\circ\psi_X\circ f^{-1}=\psi_Y$。所以 $\psi$ 在 $\mathcal C$ 上的取值被其在骨架范畴的限制确定。$\square$</p>
<hr>
<p>对于范畴 $\mathcal C$ 的对象 $X$，若对所有对象 $Y$，$\text{Hom}_{\mathcal C}(X,Y)$ 都恰有一个元素，则称 $X$ 为<strong>始对象</strong>；若对所有对象 $Y$，$\text{Hom}_{\mathcal C}(Y,X)$ 都恰有一个元素，则称 $X$ 为<strong>终对象</strong>。如果 $X$ 既是始对象又是终对象，则称 $X$ 为<strong>零对象</strong>。始/终对象间存在唯一同构。</p>
<p>若 $\mathcal C$ 中有零对象（记作 $0$），则对 $X,Y\in\text{Ob}(\mathcal C)$ 定义<strong>零态射</strong> $0:X\to Y$ 为 $X\to 0\to Y$ 的合成。零态射左右合成任何态射都是零态射，且其定义与零对象的选取无关。</p>
<p><strong>例 5</strong>：一般来说，始/终对象未必存在。</p>
<ul>
<li>$\mathsf{Set}$ 的始对象是 $\varnothing$，终对象是 ${\text{pt}}$；</li>
<li>$\textsf{Set}_\bullet$ 的零对象是 $({\text{pt}},\text{pt})$；</li>
<li>$\textsf{Grp}$ 的零对象是平凡群 ${1}$，取常值 $1$ 的同态是零态射；</li>
<li>域 $\mathbb k$ 上的向量空间范畴 $\mathsf{Vect}(\mathbb k)$ 的零对象是零空间，零态射是零映射；</li>
</ul>
<p>对于函子 $\mathcal A\xrightarrow S\mathcal C\xleftarrow T\mathcal B$，定义<strong>逗号范畴</strong> $(S/T)$ 如下：</p>
<ul>
<li>对象：$(A,B,f)$，其中 $A\in\text{Ob}(\mathcal A)$，$B\in\text{Ob}(\mathcal B)$，$f:SA\to TB$；</li>
<li>态射：从 $(A,B,f)$ 到 $(A’,B’,f’)$ 的态射形如 $(g,h)$，其中 $g:A\to A’$ 和 $h:B\to B’$ 分别是 $\mathcal A$ 和 $\mathcal B$ 中的态射，使得 $f’\circ Sg=Th\circ f$。态射的合成是 $(g_1,h_1)\circ(g_2,h_2)=(g_1\circ g_2,h_1\circ h_2)$，而 $(A,B,f)$ 到自身的恒等态射是 $(\text{id}_A,\text{id}_B)$。</li>
</ul>
<p>定义左、右投影函子 $P:(S/T)\to\mathcal A$ 和 $Q:(S/T)\to\mathcal B$。</p>
<p>设 $\mathbf 1$ 是仅含一个对象及其恒等态射的范畴，则指定 $\mathcal C$ 中的一个对象相当于指定一个函子 $j_X:\mathbf 1\to\mathcal C$。</p>
<p>考虑函子 $T:\mathcal C’\to\mathcal C$ 及 $X\in\text{Ob}(\mathcal C)$，对应于 $\mathbf 1\xrightarrow{j_X}\mathcal C\xleftarrow T\mathcal C’$ 的逗号范畴 $(X/T):=(j_X/T)$ 的对象形如 $(W,X\xrightarrow i TW)$，其中 $W\in\text{Ob}(\mathcal C’)$，而 $(W_1,i_1)$ 与 $(W_2,i_2)$ 间的态射是使得 $Th\circ i_1=i_2$ 的 $h:W_1\to W_2$。</p>
<p>反过来考虑 $\mathcal C’\xrightarrow T\mathcal C\xleftarrow{j_X}\mathbf 1$，逗号范畴 $(T/X)$ 的对象形如 $(W,TW\xrightarrow pX)$，其中 $W\in\text{Ob}(\mathcal C’)$，而 $(W_1,p_1)$ 与 $(W_2,p_2)$ 间的态射是使得 $p_2\circ Tf=p_1$ 的 $f:W_1\to W_2$。</p>
<p>逗号范畴 $(\text{id}_\mathcal C,\text{id}_\mathcal C)$ 的对象是 $\mathcal C$ 中所有态射 $X\xrightarrow f Y$，两个对象 $X\xrightarrow f Y$ 和 $X’\xrightarrow{f’}Y’$ 之间的态射是其交换图表。$(\text{id}_\mathcal C,\text{id}_\mathcal C)$ 也称为 $\mathcal C$ 的箭头范畴。</p>
<p><strong>例 6.</strong> 给定域 $\mathbb k$，定义函子 $V:\mathsf{Set}\to\mathsf{Vect}(\mathbb k)$ 如下：对于集合 $X$，$V(X):=\bigoplus_{x\in X}\mathbb kx$ 是以 $X$ 为基的 $\mathbb k$-向量空间，映射 $f:X\to Y$ 诱导出线性映射 $V(f):V(X)\to V(Y)$；令 $U:\mathsf{Vect}(\mathbb k)\to\mathsf{Set}$ 为忘却函子，则 $x\mapsto x\in V(X)$ 给出态射 $\iota:X\to UV(X)$。</p>
<p>$(V(X),\iota)$ 是 $(X/U)$ 的始对象，因为对任意 $(W,i)\in\text{Ob}(X/U)$，由 $X$ 是 $V(X)$ 的基知存在唯一的态射 $h:V(X)\to W$ 使得 $U(h)\circ\iota=i$。此即为 $V(X)$ 的<strong>泛性质</strong>。</p>
<p><strong>例 7.</strong> 考虑度量空间 $(X,d)$ 构成的范畴 $\mathsf{Metr}$，态射定义为保距映射；完备度量空间构成的全子范畴记作 $\mathsf{ComMetr}$。熟知的完备化构造给出函子 $C:\mathsf{Metr}\to\mathsf{ComMetr}$，其中 $(X,d)\mapsto(\hat X,\hat d)$。令 $I:\mathsf{ComMetr}\to\mathsf{Metr}$ 为包含函子，而对给定的度量空间 $X$，对角嵌入 $x\mapsto(x_n:=x)_{n\ge 1}$ 给出态射 $\iota:X\to I(\hat X)$。</p>
<p>$(\hat X,\iota)$ 是 $(X/I)$ 的始对象，因为对任意 $(Y,i)\in\text{Ob}(X/I)$，由 $X$ 在 $\hat X$ 的稠密性知存在唯一的态射 $h:\hat X\to Y$ 使得 $I(h)\circ\iota=i$。此即为完备化的泛性质。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>抽象代数</tag>
      </tags>
  </entry>
  <entry>
    <title>计算复杂性学习笔记</title>
    <url>/2022/03/13/complexity/</url>
    <content><![CDATA[<p>好难啊，完全不懂。</p>
<span id="more"></span>

<p>多头<strong>图灵机 (Turing Machine)</strong> 意指以下资料：</p>
<ul>
<li><p>非空有限集合 $Q$，表示读写头的状态；</p>
</li>
<li><p>非空有限集合 $\Gamma$，表示纸带的字符集，其中有初始状态 $q_0$ 和停机状态 $q_{\text{halt}}$。</p>
</li>
<li><p>$\delta:Q\times\Gamma^k\to Q\times\Gamma^{k-1}\times\{\texttt L,\texttt R,\texttt -\}^k$ 表示转移函数。</p>
</li>
</ul>
<p>在 $k+2$ 个单侧无穷的纸带上运行，分别有一个输入纸带和输出纸带。</p>
<p>称 $T:\mathbb N\to\mathbb N$ <strong>时间可构</strong> <em>time constructible</em> 是指 $T(n)\ge n$ 且存在图灵机 $M$ 在 $O(T(n))$ 的时间内计算 $T(n)$。</p>
<p><strong>定理 1.1.1</strong> 对于任意布尔函数 $f:\{0,1\}^*\to\{0,1\}$ 和可构函数 $T:\mathbb N\to\mathbb N$，若字符集 $\Sigma$ 上的图灵机 $M$ 可以在 $T(n)$ 的时间内计算 $f$，则也可以使用 ${0,1,\square,\rhd}$ 上的图灵机 $M’$ 在 $4\log|\Gamma|\cdot T(n)$ 的时间内计算 $f$。</p>
<blockquote>
<p> $\Gamma$ 可以用 $\{0,1\}^{\log|\Gamma|}$ 表示，然后在 $Q$ 里搞状压即可<del>具体构造 gun 吧</del></p>
</blockquote>
<p><strong>定理 1.1.2</strong> 对于任意布尔函数 $f:\{0,1\}^*\to\{0,1\}$ 和可构函数 $T:\mathbb N\to\mathbb N$，若 $k$ 头图灵机 $M$ 可以在 $T(n)$ 的时间内计算 $f$，则也可以使用单头图灵机 $M’$ 在 $5k\cdot T(n)^2$ 的时间内计算 $f$。</p>
<blockquote>
<p>第 $i$ 个纸带的第 $j$ 个位置放到 $ki+j$，每一步扫一遍记到寄存器里。</p>
</blockquote>
<p>此处图灵机 $M’$ 的运行不依赖于除长度外的具体输入内容，这样的图灵机称为 <em>oblivious</em> 的。</p>
<p><strong>定理 1.1.3</strong> 对于任意布尔函数 $f:\{0,1\}^*\to\{0,1\}$ 和可构函数 $T:\mathbb N\to\mathbb N$，若纸带双侧无穷的图灵机 $M$ 可以在 $T(n)$ 的时间内计算 $f$，则也可以使用纸带单侧无穷的图灵机 $M’$ 在 $4\cdot T(n)$ 的时间内计算 $f$。</p>
<blockquote>
<p>把纸带对折就完事了 /kx</p>
</blockquote>
<p>图灵机 $M$ 可以用二进制串 $\lceil M\rfloor$ 表示，字符串 $\alpha$ 对应的图灵机记作 $M_\alpha$。</p>
<p><strong>定理 1.1.4</strong> 存在图灵机 $\mathcal U$ 使得对任意 $x,a\in\{0,1\}^*$，$\mathcal U(x,a)=M_\alpha(x)$，且若 $M_\alpha(x)$ 在 $T$ 步内停机，则 $\mathcal U(x,a)$ 在 $O(T\log T)$ 步内停机。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/260512272">https://zhuanlan.zhihu.com/p/260512272</a></p>
</blockquote>
<p><strong>定理 1.1.5</strong> 存在布尔函数 $\textsf{UC}:\{0,1\}^*\to\{0,1\}$ 是不可计算函数。</p>
<blockquote>
<p>对于 $\alpha\in{0,1}^*$，定义 $\textsf{UC}(\alpha)=0\iff M_\alpha(\alpha)$ 在有限步内输出 $1$。</p>
<p>若图灵机 $M$ 计算 $\textsf{UC}$，则 $M(\lceil M\rfloor)$ 既不是 $0$ 也不是 $1$，矛盾。</p>
</blockquote>
<p><strong>定理 1.1.6</strong> 定义 $\textsf{HALT}(\alpha,x)=1\iff M_\alpha(x)$ 在有限步内停机，则 $\textsf{HALT}$ 是不可计算函数。</p>
<blockquote>
<p>若图灵机 $M_{\textsf{HALT}}$ 计算 $\textsf{HALT}$，则构造 $M_{\textsf{UC}}$ 如下：对于输入 $\alpha$，计算 $M_{\textsf{HALT}}(\alpha,\alpha)$，若为 $0$ 则输出 $1$，否则计算 $\mathcal U(\alpha,\alpha)$ 输出取反的值，矛盾。</p>
</blockquote>
<hr>
<p><strong>复杂度类</strong> <em>complexity class</em> 是指在给定资源下可以计算的函数集合。</p>
<p>布尔函数 $f:\{0,1\}^*\to\{0,1\}$ 对应的<strong>语言</strong> <em>language</em> $L_f=\{x:f(x)=1\}$。</p>
<p>对于函数 $T:\mathbb N\to\mathbb N$ 和 $L\subset\{0,1\}^*$，$L\in\mathbf{DTIME}(T(n))$ 是指可以在 $O(T(n))$ 时间内计算。$\mathbf P:=\bigcup_{c\ge 1}\mathbf{DTIME}(n^c)$。</p>
<p>语言 $L\subset\{0,1\}^*$ 属于 $\mathbf{NP}$ 当且仅当存在多项式 $p:\mathbb N\to\mathbb N$ 和多项式时间的图灵机 $M$ 使得 $x\in L\iff$ 存在 $u\in\{0,1\}^{p(|x|)}$ 使得 $M(x,u)=1$，称 $u$ 是 $x$ 的证明 <em>certificate</em>。</p>
<p><strong>非确定性图灵机 (Non-Deterministic Turing Machine)</strong> 相比(确定性)图灵机有 $2$ 个转移函数，在运行中非确定地选择其一运行，且所有执行方式都可能对结果产生影响。</p>
<p>对于函数 $T:\mathbb N\to\mathbb N$ 和 $L\subset\{0,1\}^*$，$L\in\mathbf{NTIME}(T(n))$ 是指可以在 $O(T(n))$ 时间内用 NDTM 计算。</p>
<p><strong>定理 1.2.1</strong> $\mathbf{NP}=\bigcup_{c\ge 1}\mathbf{NTIME}(n^c)$。</p>
<p>定义 $A\subset\{0,1\}^*$ <strong>多项式时间归约</strong> <em>polynomial-time reducible</em> 到 $B\subset\{0,1\}^*$ 是指存在多项式时间函数 $f:\{0,1\}^*\to\{0,1\}^*$ 使得 $x\in A\iff f(x)=B$，记作 $A\le_p B$。传递性显然。</p>
<p>称 $B$ 是 $\mathbf{NP}\textit{-hard}$ 是指对所有 $A\in\mathbf{NP}$ 都有 $A\le_p B$，若又有 $B\in\mathbf{NP}$ 则是 $\mathbf{NP}\textit{-complete}$。</p>
<p><strong>定理 1.2.2</strong> $\textsf{TMSAT}=\{\langle\alpha,x,1^n,1^t\rangle:\exists u\in\{0,1\}^n$ 使得 $M_\alpha(x,u)$ 在 $t$ 步内输出 $1\}$ 是 $\mathbf{NP}\textit{-complete}$。</p>
<p>$u_1,\cdots,u_n$ 上的布尔公式若是子句 <em>clause</em> 的合取则称为<strong>合取范式 (CNF)</strong> <em>Conjunctive Normal Form</em>，形如 $\bigwedge_i(\bigvee_jv_{i_j})$，若每个子句恰有 $k$ 个文字 <em>literal</em> 则称为 $k\text{CNF}$。</p>
<p><strong>定理 1.2.3</strong> $\textsf{SAT}/\textsf{3SAT}$ 分别表示所有可满足的 $\text{CNF}/\text{3CNF}$ 公式，都是 $\mathbf{NP}\textit{-complete}$ 的。</p>
<blockquote>
<p><strong>引理 1.</strong> 布尔函数 $f:\{0,1\}^\ell\to\{0,1\}$ 可以用长度不超过 $\ell2^\ell$ 的 CNF 公式表示。</p>
<p><strong>引理 2.</strong> $\textsf{SAT}$ 是 $\mathbf{NP}\textit{-hard}$。</p>
<p><strong>证明.</strong> 设 $L$ 是 $\mathbf{NP}$，由定义设多项式 $p:\mathbb N\to\mathbb N$ 和图灵机 $M$，使得 $x\in L\iff\exists u\in\{0,1\}^{p(|x|)}$ 使得 $M(x,u)=1$。</p>
<p>考虑对 $x\in\{0,1\}^*$ 构造 CNF 公式 $\varphi_x$ 使得 $x\in L\iff\varphi_x$ 是可满足的。</p>
<p>设 CNF 公式 $\psi_x:u\in\{0,1\}^{p(|x|)}\mapsto M(x,u)$，但 $\psi_x$ 的长度太大了，然后就不会了 qaq</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算理论</tag>
      </tags>
  </entry>
</search>
